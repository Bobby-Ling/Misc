# 正则表达式

<!-- # 普通字符
> 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。
- `[ABC] `
- `[^ABC] `
- `[A-Z] `
- `. ` (=`[^\n\r] `)除换行符（\n、\r）之外的任何单个字符
- `[\s\S] ` 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。
- `\w ` (=`[A-Za-z0-9_] `) 字母、数字、下划线
# 非打印字符
- \cx 匹配由x指明的控制字符,x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
- \f 换页符(= \x0c 和 \cL) -->

## 元字符

### 匹配位置的元字符

- `^` 行的开始
- `$` 行的结尾
- `\b` 单词的开始或结尾
- `\B` 非单词的开始或结尾
- `\z` 字符串的结尾
- `\Z` 字符串的结尾或字符串结尾处的换行符号\n之前
- `\A` 字符串的开头
- `\G` 上一个匹配结束的地方
- Examples

```bash
^string$ # 精确匹配
^$ # 一个空行
^ # 任意行
\bstring\b # 单词string
string # 与任何包含string的字符串匹配
```

### 匹配字符的元字符

- `.`（点号）匹配除换行符之外的任意字符;
- `\w` 匹配单词字符（包括字母、数字、下画线和汉字）;
- `\W` 匹配任意的非单词字符;
- `\s` 匹配任意的空白字符，如空格、制表符、换行符、中文全角空格等;
- `\S` 匹配任意的非空白字符;
- `\d` 匹配任意的数字;
- `\D` 匹配任意的非数字字符
- Examples

```bash
^.*$ 非空行
^\w*$ 仅有一个单词的行
```

### 字符类

匹配[...] (集合)中的一个字符

- 转义 `.、 $、 ^、 {、 [、 (、 |、 )、 *、 +、 ?、\`需要转义
- 注意

> 元字符在字符类中不做任何特殊处理，它仅仅表示一个自身的字符

- Examples

```bash
[ABC] 
[^ABC]
[A-Z]
[-a] `a `或`- `
[0-9a-zA-Z_] # 等价于\w
[ \f\r\t\n] #  匹配所有的白字符
```

### 限定符

- 贪婪限定符
  `{n}` 重复n次
  `{n,}` 重复至少n次
  `{n,m}` 重复至少n次，最多m次
  `*` 重复至少0次，等同于{0,}
  `+` 重复至少1次，等同于{1,}
  `?` 重复0次或1次，等同于{0,1}
- 懒惰限定符
  `*?` 尽可能少地使用重复的第一个匹配
  `+?` 尽可能少地使用重复但至少使用一次
  `??` 使用零次重复（如有可能）或一次重复
  `{n}?` 等同于{n}
  `{n,}?` 尽可能少地使用重复，但至少使用n次
  `{n,m}?` 介于n次和m次之间、尽可能少地使用重复
- Examples

```bash
a.*b 
# 匹配aabab
a.*?b # 懒惰模式
# 匹配aab和ab,而非aabab
```

### 运算

- `|` 或(替换)运算
先匹配左侧,左侧部分不匹配时才尝试匹配右侧部分
- `(?(expression)yes|no)`
表达式要么与“yes”部分匹配,要么与“no”部分匹配。其中,“no”部分可省略

```bash
对于12345-678和12345
\d{5}-\d{3}|\d{5}
# 会匹配12345-678和12345
\d{5}|\d{5}-\d{3}
# 只会匹配12345
```

### 分组

将`( )`中的表达式视为一个单位
```bash
(\d{1,3}\.){3}\d{1,3}
# 匹配IP地址
```

- 反向引用
分组后从左至右编号,可通过`\number`引用,表示匹配重复的字符串

```bash
`\b(\w)\1\b ` # 只匹配含有两个相同字符的单词
`\b(\w)\w\b ` # 则匹配具有两个字符（可以相同,也可以不相同）的单词
```

### 先行断言(lookahead)和后行断言(lookbehind)

- 零宽,指匹配的是一个位置
- 负向和正向的区别,就在于该位置之后的字符能否匹配括号中的表达式
- 关于先行(lookahead)和后行(lookbehind)：正则表达式引擎在执行字符串和表达式匹配时，会从头到尾（从前到后）连续扫描字符串中的字符，设想有一个扫描指针指向字符边界处并随匹配过程移动。先行断言，是当扫描指针位于某处时，引擎会尝试匹配指针还未扫过的字符，先于指针到达该字符，故称为先行。后行断言，引擎会尝试匹配指针已扫过的字符，后于指针到达该字符，故称为后行。
- 用圆括号分组会有一个副作用,即相关的匹配会被缓存,此时可用非捕获元如`?:` `?=` `?!`放在第一个选项前来消除这种副作用
- (?=pattern) 零宽正向先行断言(zero-width positive lookahead assertion)
  - 代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern
  - `exp1(?=exp2)` 查找 exp2 前面的 exp1
  ```
  # 匹配"a regular expression"中"regular"的re
  re(?=gular)
  # 匹配reg
  re(?=gular).
  ```
- (?!pattern) 零宽负向先行断言(zero-width negative lookahead assertion)
  - 代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern
  - `exp1(?!exp2)`查找后面不是 exp2 的 exp1
- (?<=pattern) 零宽正向后行断言(zero-width positive lookbehind assertion)
  - 代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 pattern。
  - `(?<=exp2)exp1` 查找 exp2 后面的 exp1
- (?<!pattern) 零宽负向后行断言(zero-width negative lookbehind assertion)
  - 代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern。
  - `(?<!exp2)exp1`查找前面不是 exp2 的 exp1。

### 匹配选项(修饰符)

`/pattern/flags`

- `g` global - 全局匹配
- `i` ignore - 不区分大小写
- `m` global - 全局匹配
- `s` 特殊字符圆点`.`中包含换行符`\n`
(默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 之后, . 中包含换行符 \n)

### 优先级顺序

1. \ 转义符
1. ()、 (?:)、 (?=)、 [] 圆括号和方括号
1. *、 +、 ?、 {n}、 {n,}、 {n,m} 限定符
1. ^、 $、 \（元字符） 位置和顺序
1. | “或”运算

### 案例学习

```bash
^(0|-?[1-9]\d*)\b
^(0|-?[1-9]\d{0,})\b
^(0|-?[1-9][0-9]*)\b
# 任意整数

^[-]?[0-9]+\.?[0-9]+$  
^[-]?[0-9]+(\.[0-9]+)?$
# 所有的浮点数

^[a-zA-Z0-9_]{1,}$
^[a-zA-Z0-9_]+$ 
# 所有包含一个以上的字母、数字或下划线的字符串 

```
