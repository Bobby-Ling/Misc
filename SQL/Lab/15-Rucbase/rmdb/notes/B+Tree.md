# B+ Tree

## 数据结构定义

```cpp
// 每个结点最多可插入的键值对数量; 即B+树阶数M
int btree_order;  
// MaxSize=M+1
int GetMaxSize() { return file_hdr->btree_order + 1; }
// MinSize=floor((M+1)/2)=ceil(M/2)
int GetMinSize() { return GetMaxSize() / 2; }
```
实验中, 内部节点的K与V数目相等(最开始多出一个K0)  
内部节点: [MinSize, MaxSize)    
        [ceil(M/2),M]
        [2,3]  
        注意, 一般为[ceil(M/2)-1,M-1]个K, [ceil(M/2),M]个V  
叶子节点: [MinSize, MaxSize-1)
        [ceil(M/2),M-1]
        [2,2]  

## 插入

(假定原树不存在此节点)
1. 找到叶节点, 插入
2. 检查插入后是否满足数目条件: N<=M-1(叶子);N<=M(内部)  
    (N为当前KV数目)
    1. 满足: 结束
    2. 不满足: (此时数目N为M(叶子);M+1(内部))  
        1. 分裂:  
            - 叶子节点: [0,M/2-1],[M/2,M-1];[M/2]  
                ```cpp
                e.g. M=3, {0,1,2}->{0},{1,2};{1}  
                     M=4, {0,1,2,3}->{0,1},{2,3};{2}  
                ```
            - 内部节点: [0,M/2],[M/2+1,M];[M/2+1]  
                ```cpp
                e.g. M=3, {0,1,2,3}->{0,1},{2,3};{2}  
                     M=4, {0,1,2,3,4}->{0,1,2},{3,4};{3}  
                如果没有K0的话, 就和叶子节点一样了: {0,1,2,3}->{1},{2,3};{2}  
                ```
        2. 插入并检查父节点是否满足数目条件
            1. 满足: 结束
            2. 不满足: 转2.2.1

## 删除

(假定原树存在此节点)
1. 找到叶节点, 删除
2. 检查删除后是否满足数目条件N>=M-1(叶子);N<=M(内部)  
    (N为当前数目)
    
    
